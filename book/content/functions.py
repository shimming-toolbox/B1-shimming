import matplotlib.pyplot as plt
import numpy as np
import scipy

from scipy.stats import variation


def montage(X, colormap='gray'):
    """Concatenates images stored in a 3D array and displays them
    Args:
        X: 3D array with the last dimension being the one in which the different images are stored
        colormap: colors in which the montage will be displayed
    """
    x, y, n_images = np.shape(X)
    n_frames = int(np.ceil(np.sqrt(n_images)))
    result = np.zeros((n_frames * x, n_frames * y))
    image_id = 0
    for k in range(n_frames):
        for j in range(n_frames):
            if image_id >= n_images:
                break
            sliceM, sliceN = j * x, k * y
            result[sliceN:sliceN + x, sliceM:sliceM + y] = X[:, :, image_id]
            image_id += 1

    plt.imshow(result, cmap=colormap)
    plt.axis('off')


def show_weights(weights):
    t = np.linspace(0, np.pi * 2, 100)
    circle = plt.plot(np.cos(t), np.sin(t), linewidth=2, color='black')
    legend_circle = plt.legend(handles=[circle[0]],  labels=['Unit Circle'], loc=4)
    for i in range(len(weights)):
        plt.plot(np.real(weights[i]), np.imag(weights[i]), 'o', markersize=10, label=f'Tx {i + 1}')
    plt.tick_params(length=0, pad=10, labelsize=12)
    plt.legend(loc=1, framealpha=0.5)
    plt.gca().add_artist(legend_circle)
    plt.axis('equal')


def print_cov(array, text=None):
    if text:
        print(f'CoV ({text}): \033[1m {(array.std() / array.mean()).round(decimals=3)}\033[0m')
    else:
        print(f'CoV: \033[1m {(array.std() / array.mean()).round(decimals=3)}\033[0m')


def simulate_b1_maps(n_Tx, wavelength_size):
    """
    Simulate complex B1+ maps in a 2D circular phantom.
    Args:
        n_Tx (int): number of transmit elements evenly spaced around the sphere.
        wavelength_size (int): size of the B1+ wavelength in pixels.

    Returns:
        numpy.ndarray: complex B1+ maps (x, y, n_Tx).
        numpy.ndarray: x and y coordinated of the different transmit elements (n_Tx, 2).

    """
    FOV_size = 150  # Number of pixels in both image directions

    # Create the mask (circle at the center of the image)
    mask = np.zeros((FOV_size, FOV_size))
    for j in range(FOV_size):
        for k in range(FOV_size):
            if ((j - (FOV_size // 2)) ** 2 + (k - (FOV_size // 2)) ** 2) <= 2500:
                mask[j, k] = 1

    # 2D coordinates of the Tx elements (evenly spaced around the circle)
    complex_coordinates = np.exp(1j * np.linspace(0, 2 * (np.pi - np.pi / n_Tx), n_Tx)) / 2.8
    Tx_positions = np.zeros((n_Tx, 2))
    Tx_positions[:, 0] = np.round(FOV_size * np.real(complex_coordinates) + FOV_size / 2)  # x coordinates
    Tx_positions[:, 1] = np.round(FOV_size * np.imag(complex_coordinates) + FOV_size / 2)  # y coordinates

    field = 10  # Field strength locally generated by a Tx element
    dist = np.zeros((FOV_size, FOV_size, n_Tx))

    for j in range(FOV_size):
        for k in range(FOV_size):
            # Distance to the transmit element
            dist[j, k, :] = np.linalg.norm([(Tx_positions[:, 0] - j), (Tx_positions[:, 1] - k)], axis=0)

    dist[dist == 0] = 1  # Avoid division by 0 in next line (sets the field at the Tx element position)
    magnitude = field / dist  # Linear decrease of magnetic field with distance to the transmit element
    phase = (2 * np.pi / wavelength_size * dist % (2 * np.pi)) - np.pi
    mask_3d = np.repeat(mask[:, :, np.newaxis], n_Tx, axis=2)  # Repeat max n_Tx times to mask all Tx at once
    magnitude *= mask_3d  # Remove all magnitude values outside of mask
    phase *= mask_3d  # Remove all phase values outside of mask

    # Return complex B1+ field
    return magnitude * np.exp(1j * phase), Tx_positions


def phase_only_shimming(b1_maps, mask=None, initial_weights=None):
    """
    Computes optimized phase-only shim weights.
    Args:
        b1_maps (numpy.ndarray): complex B1+ maps (x, y, n_Tx).
        mask (numpy.ndarray): region of interest in which optimization is performed (x, y).
        initial_weights (numpy.ndarray): 1D vector of complex shim weights used as a starting point for optimization.

    Returns:
        numpy.ndarray: Phase-only shim weights.
    """
    x, y, n_Tx = b1_maps.shape

    if mask is None:
        mask = b1_maps[:, :, 0] != 0

        # Starting optimization from single pulse excitation (all elements in phase) if no initial weights provided
    if initial_weights is None:
        initial_weights = np.zeros(n_Tx)

    # Only keep the values in the mask to speed up the optimization process
    b1_roi = np.reshape(b1_maps * mask[:, :, np.newaxis], [x * y, n_Tx])
    b1_roi = b1_roi[b1_roi[:, 0] != 0, :]

    # The cost function is CoV(|B1+|). Shim weights will be determined by minimizing it
    def cost_function(phases):
        return variation(np.abs(b1_roi @ (np.exp(1j * phases))))

    shimmed_phases = scipy.optimize.minimize(cost_function, initial_weights).x  # Finding the optimized phase values
    return np.ones(n_Tx) * np.exp(1j * shimmed_phases)  # Computing the corresponding complex shim weights


def vector_to_complex(weights):
    """
    Combines magnitude and phase values contained in a vector into a half long complex vector.
    Args:
        weights (numpy.ndarray): 1D array of length 2*n_coils. First/second half: magnitude/phase of the shim weights.
    Returns:
        numpy.ndarray: 1D complex array of length n_coils.
    """
    return weights[:len(weights) // 2] * np.exp(1j * weights[len(weights) // 2:])


def complex_to_vector(weights):
    """
    Combines separates magnitude and phase values contained in a complex vector into a twice as long vector.
    Args:
        weights (numpy.ndarray): 1D complex array of length n_coils.
    Returns:
        numpy.ndarray: 1D array of length 2*n_coils. First/second half: magnitude/phase of the shim weights.
    """
    return np.concatenate((np.abs(weights), np.angle(weights)))
